#include <algorithm>
#include <cassert>
#include <cctype>
#include <concepts>
#include <cstdlib>
#include <functional>
#include <map>
#include <ranges>
#include <sstream>
#include <stdexcept>
#include <string>
#include <variant>
#include <vector>

#include "fab.h"

namespace {
std::string
sv_to_string(std::string_view sv) {
  return std::string{sv.cbegin(), sv.cend()};
}

template <typename Container, typename T, typename MkExn>
const auto &
find_or_throw(const Container &haystack, const T &needle,
              MkExn &&mk) requires std::invocable<MkExn> {
  auto it = haystack.find(needle);

  if (it == std::end(haystack)) {
    throw mk();
  }

  return *it;
}

template <typename S>
concept Concat = requires(S s) {
  { std::string{} + s } -> std::same_as<std::string>;
};

template <typename R, typename D>
std::string
foldl(R &&range, const D &delim) requires std::ranges::range<R> && Concat<D> {
  std::string s = {};

  bool first = true;
  for (const auto &e : range) {
    if (!first) {
      s += delim;
    }

    s += e;
    first = false;
  }

  return s;
}
} // namespace

namespace detail {
struct FabError final : std::runtime_error {
  template <typename T, typename U>
  struct Unexpected {
    const T expected;
    const U actual;
  };

  using UnexpectedCharacter = Unexpected<char, char>;
  using UnexpectedTokenType = Unexpected<TokenType, TokenType>;
  using TokenNotInExpectedSet =
      Unexpected<std::vector<Option<TokenType>>, Option<TokenType>>;

  struct UndefinedVariable {
    const std::string_view var;
  };

  struct UnknownTarget {
    const std::string_view target;
  };

  struct ExpectedLValue {
    const std::string_view macro;
  };

  struct UnexpectedEof {};

  struct BuiltInMacrosRequireActionScope {};

  struct GetErrMsg {
    template <typename T>
    std::string operator()(const Unexpected<T, T> &u) const {
      auto ss = std::stringstream{};
      ss << "expected: " << u.expected << "; got: " << u.actual;
      return ss.str();
    }

    template <typename T>
    std::string operator()(const Unexpected<std::vector<T>, T> &u) const {
      auto ss = std::stringstream{};
      ss << "expected one of: {";

      ss << foldl(u.expected | std::views::transform([](auto e) {
                    std::stringstream ss = {};
                    ss << e;
                    return ss.str();
                  }),
                  ", ");

      ss << "}; got: " << u.actual;
      return ss.str();
    }

    std::string operator()(const UndefinedVariable &uv) const {
      return "undefined variable: " + sv_to_string(uv.var);
    }

    std::string operator()(const UnknownTarget &ut) const {
      return "no rule to make target `" + sv_to_string(ut.target) + "'";
    }

    std::string operator()(const ExpectedLValue &e) const {
      return "expected lvalue but got macro at: " + sv_to_string(e.macro);
    }

    std::string operator()(const UnexpectedEof &) const {
      return "unexpected <EOF>";
    }

    std::string operator()(const BuiltInMacrosRequireActionScope &) const {
      return "built in macros are only valid in action blocks.";
    }
  };

  using ErrTy = std::variant<BuiltInMacrosRequireActionScope, ExpectedLValue,
                             TokenNotInExpectedSet, UndefinedVariable,
                             UnexpectedCharacter, UnexpectedEof,
                             UnexpectedTokenType, UnknownTarget>;

  explicit FabError(const ErrTy &ty)
      : std::runtime_error(std::visit(GetErrMsg{}, ty)) {
  }
};

template <typename R>
auto
copy_collect(R &&range) requires std::ranges::range<R> {
  std::vector<std::ranges::range_value_t<R>> out = {};
  std::ranges::copy(range, std::back_inserter(out));
  return out;
}

struct LValue {
  const std::string_view iden;
};

struct RValue {
  const std::string_view iden;
};

struct TargetAlias {};

struct PrereqAlias {};

using ValueType = std::variant<LValue, RValue, TargetAlias, PrereqAlias>;

// An association is generated by the first pass of parsing. It consists of an
// lvalue or an rvalue -- packed into the ValueType variant -- that will be
// resolved some point later on in parsing.
using Association = std::tuple<std::string_view, std::vector<ValueType>>;

// Intermediate representation for Rules -- after parsing they'll need to be
// resolved by looking each `ValueType` variant up in the environment.
struct RuleIr {
  const ValueType target;
  const std::vector<ValueType> prereqs;
  const std::vector<std::vector<ValueType>> actions;
};

struct Fill {
  static std::string_view get_extension(std::string_view s) {
    auto offset = s.rfind(".");

    if (offset == std::string_view::npos) {
      throw 0; // FIXME: FabError(FabError::InvalidFill{.fill = s});
    }

    offset += 1;
    assert(offset < s.size());
    return s.substr(offset);
  }

  const std::string_view target;
  const std::string_view target_ext;
  const std::string_view prereq;
  const std::string_view prereq_ext;

  Fill(std::string_view t, std::string_view p)
      : target(t)
      , target_ext(get_extension(t))
      , prereq(p)
      , prereq_ext(get_extension(p)) {
  }
};

struct Stencil {
  const std::string_view target_ext;
  const std::string_view prereq_ext;
  const std::vector<std::vector<ValueType>> action_list;
};

bool
operator==(const Stencil &lhs, const Fill &rhs) {
  return std::tie(lhs.target_ext, lhs.prereq_ext) ==
         std::tie(rhs.target_ext, rhs.prereq_ext);
}

struct Ir {
  const std::vector<RuleIr> rules;
  const std::vector<Association> associations;
};

class LexState {
  const std::string_view buf;
  std::string_view::const_iterator m_offset = buf.cbegin();

public:
  LexState(std::string_view source)
      : buf(source) {
  }

  [[nodiscard]] char next() {
    if (eof()) {
      throw FabError(FabError::UnexpectedEof{});
    }

    char c = *m_offset;
    m_offset = std::next(m_offset);
    return c;
  }

  bool eof() const {
    return m_offset == buf.cend();
  }

  void eat(char expected) {
    if (expected != *m_offset) {
      throw FabError(FabError::UnexpectedCharacter{.expected = expected,
                                                   .actual = *m_offset});
    }

    assert(next() == expected);
  }

  Option<char> peek() const {
    if (eof()) {
      return {};
    }

    return *m_offset;
  }

  template <typename I>
  std::string_view extract_lexeme(I begin,
                                  I end) requires std::input_iterator<I> {
    return std::string_view{begin, end};
  }

  template <typename P>
  auto eat_until(P pred) requires std::predicate<P, char> {
    const auto begin = m_offset;

    while (!pred(next()))
      ;

    assert(m_offset != buf.begin());
    m_offset = std::prev(m_offset);

    return std::tuple{begin, m_offset};
  }
};

class ParseState {
  const std::vector<Token> tokens;
  std::vector<Token>::const_iterator m_offset = tokens.cbegin();
  std::vector<Association> m_associations = {};
  std::vector<Fill> m_fills = {};
  std::vector<RuleIr> m_rules = {};
  std::vector<Stencil> m_stencils = {};

private:
  const Token &eat(TokenType expected) {
    const auto &actual = *m_offset;

    if (expected != actual.token_type()) {
      throw FabError(FabError::UnexpectedTokenType{
          .expected = expected, .actual = actual.token_type()});
    }

    m_offset = std::next(m_offset);
    return actual;
  }

  template <TokenType ty>
  std::string_view eat_for_lexeme() {
    return eat(ty).lexeme<ty>();
  }

  std::tuple<std::vector<ValueType>, std::vector<std::vector<ValueType>>>
  rule() {
    if (peek() != TokenType::LBrace) {
      eat(TokenType::Arrow);
    }

    std::vector<ValueType> prereqs = this->prereqs();

    if (peek() == TokenType::SemiColon) {
      eat(TokenType::SemiColon);
      return std::make_tuple(std::move(prereqs),
                             std::vector<std::vector<ValueType>>{});
    }

    std::vector<std::vector<ValueType>> actions = this->action();
    return std::tuple{std::move(prereqs), std::move(actions)};
  }

  TokenType peek() const {
    if (eof()) {
      throw FabError(FabError::UnexpectedEof{});
      return {};
    } else {
      return m_offset->token_type();
    }
  }

  ValueType iden_status() {
    auto peeked = peek();

    if (TokenType::Iden == peeked) {
      return RValue{eat_for_lexeme<TokenType::Iden>()};
    } else if (TokenType::Macro == peeked) {
      return LValue{eat_for_lexeme<TokenType::Macro>()};
    } else if (TokenType::TargetAlias == peeked) {
      eat(TokenType::TargetAlias);
      return TargetAlias{};
    } else if (TokenType::PrereqAlias == peeked) {
      eat(TokenType::PrereqAlias);
      return PrereqAlias{};
    } else {
      throw FabError(FabError::TokenNotInExpectedSet{
          .expected = {{TokenType::Iden}, {TokenType::Macro}},
          .actual = peeked});
    }
  }

  ValueType target() {
    return iden_status();
  }

  std::vector<ValueType> prereqs() {
    return iden_list();
  }

  static bool matches(TokenType) {
    return false;
  }

  template <typename... Tl>
  static bool matches(TokenType expected, TokenType head, Tl... tail) {
    return expected == head || matches(expected, tail...);
  }

  std::vector<std::vector<ValueType>> action() {
    eat(TokenType::LBrace);

    bool done = false;
    auto actions = std::vector<std::vector<ValueType>>{};

    while (!done) {
      actions.push_back(iden_list());
      eat(TokenType::SemiColon);

      if (TokenType::RBrace == peek()) {
        done = true;
      }
    }

    eat(TokenType::RBrace);
    return actions;
  }

  std::vector<ValueType> iden_list() {
    std::vector<ValueType> idens;

    while (ParseState::matches(peek(), TokenType::Iden, TokenType::Macro,
                               TokenType::TargetAlias,
                               TokenType::PrereqAlias)) {
      idens.push_back(iden_status());
    }

    return idens;
  }

  std::vector<ValueType> assignment() {
    eat(TokenType::Eq);
    auto idens = iden_list();
    eat(TokenType::SemiColon);
    return idens;
  }

  void stencil() {
    auto target_ext = eat_for_lexeme<TokenType::Stencil>();
    auto prereq_ext = std::string_view{""};

    if (peek() != TokenType::LBrace) {
      eat(TokenType::Arrow);
      prereq_ext = eat_for_lexeme<TokenType::Stencil>();
    }

    m_stencils.push_back(Stencil{.target_ext = target_ext,
                                 .prereq_ext = prereq_ext,
                                 .action_list = std::move(action())});
  }

  void fill() {
    auto target = eat_for_lexeme<TokenType::Fill>();
    auto prereq = std::string_view{""};

    if (peek() != TokenType::SemiColon) {
      eat(TokenType::Arrow);
      prereq = eat_for_lexeme<TokenType::Fill>();
    }

    eat(TokenType::SemiColon);
    m_fills.push_back(Fill{target, prereq});
  }

public:
  ParseState(std::vector<Token> &&tokens)
      : tokens(tokens) {
  }

  void stmt_list() {
    if (peek() == TokenType::Stencil) {
      stencil();
      return;
    }

    if (peek() == TokenType::Fill) {
      fill();
      return;
    }

    auto iden = iden_status();
    auto peeked = peek();

    if (peeked == TokenType::Eq) {
      if (std::holds_alternative<RValue>(iden)) {
        auto lhs = std::get<RValue>(iden).iden;
        auto rhs = assignment();
        m_associations.emplace_back(lhs, rhs);
      } else {
        throw FabError(
            FabError::ExpectedLValue{.macro = std::get<LValue>(iden).iden});
      }
    } else if (ParseState::matches(peeked, TokenType::Arrow,
                                   TokenType::LBrace)) {
      auto [prereqs, actions] = rule();
      m_rules.push_back(
          {.target = iden, .prereqs = prereqs, .actions = actions});
    } else {
      throw FabError(
          FabError::TokenNotInExpectedSet{.expected = {{TokenType::Eq},
                                                       {TokenType::Arrow},
                                                       {TokenType::LBrace}},
                                          .actual = peeked});
    }
  }

  bool eof() const {
    assert(m_offset != tokens.cend());
    return m_offset->token_type() == TokenType::Eof;
  }

  Ir into_ir() && {
    for (const auto &fill : m_fills) {
      auto matching = std::find(m_stencils.cbegin(), m_stencils.cend(), fill);

      if (matching == m_stencils.end()) {
        throw std::runtime_error{"No matching stencil for fill."};
      } else {
        m_rules.push_back(detail::RuleIr{
            .target = detail::RValue{.iden = fill.target},
            .prereqs = std::vector<detail::ValueType>{detail::RValue{
                .iden = fill.prereq}},
            .actions = matching->action_list});
      }
    }

    return Ir{
        .rules = std::move(m_rules),
        .associations = std::move(m_associations),
    };
  }
};

namespace resolve {
template <typename Visitor, typename Variant>
concept Visit = requires(Visitor visitor, Variant variant) {
  std::visit(visitor, variant);
};

template <typename Variant>
constexpr auto
make_visitc(auto visitor) requires Visit<decltype(visitor), Variant> {
  return [=](const Variant &variant) { return std::visit(visitor, variant); };
}

// Fab's grammar supplies two main scopes: action and _everything else_.  The
// only really special thing about action scope is visibility of _special_
// macros -- namely make(1) style '$@' and '$<' to refer to the current target
// and prerequisites, respectively. By design, this is not caught by the
// parser (since it be just be a few more nasty if checks). Instead, this is
// encoded directly into ValueType with the variants TargetAlias and
// PrereqAlias. Resolver operator() overloads constrain their parameters with
// these two concepts to disallow invalid Fab programs.
template <typename T>
concept ActionScope =
    std::is_same<TargetAlias, T>::value || std::is_same<PrereqAlias, T>::value;

template <typename T>
concept FileScope =
    std::is_same<RValue, T>::value || std::is_same<LValue, T>::value;

struct Resolver {
  const std::map<std::string_view, std::string> &macros;

  std::string_view operator()(const RValue &term) const {
    return term.iden;
  }

  std::string_view operator()(const LValue &res) const {
    auto pair = find_or_throw(macros, res.iden, [&res] {
      return FabError(FabError::UndefinedVariable{.var = res.iden});
    });

    return pair.second;
  }

  template <typename T>
  std::string_view operator()(const T &) const requires ActionScope<T> {
    throw FabError(FabError::BuiltInMacrosRequireActionScope{});
  }
};

struct ActionResolver {
  const std::string_view target;
  const std::vector<std::string_view> prereqs;
  const std::map<std::string_view, std::string> &macros;

  std::string operator()(const TargetAlias &) const {
    return sv_to_string(target);
  }

  std::string operator()(const PrereqAlias &) const {
    return foldl(prereqs, " ");
  }

  template <typename T>
  std::string operator()(const T &variant) const requires FileScope<T> {
    return sv_to_string(Resolver{macros}(variant));
  }
};

namespace detail {
std::map<std::string_view, std::string>
resolve_associations(const std::vector<Association> &associations) {
  const auto base_resolver = [](const auto &association, auto &&transformer) {
    auto [k, vs] = association;
    return std::make_pair(k,
                          foldl(vs | std::views::transform(transformer), " "));
  };

  const auto is_rvalue = [](const Association &association) {
    auto [k, vs] = association;
    return std::ranges::all_of(
        vs, [](const auto &v) { return std::holds_alternative<RValue>(v); });
  };

  const auto resolve_as_rvalue = [base_resolver](const auto &association) {
    const auto into_rvalue = [](const auto &v) {
      return std::get<RValue>(v).iden;
    };

    return base_resolver(association, into_rvalue);
  };

  auto resolved = std::map<std::string_view, std::string>{};
  std::ranges::move(
      std::views::transform(associations | std::views::filter(is_rvalue),
                            resolve_as_rvalue),
      std::inserter(resolved, resolved.begin()));

  const auto resolve_with_visitor = [&macros = std::as_const(resolved),
                                     base_resolver](const auto &association) {
    const auto visitc = make_visitc<ValueType>(Resolver{macros});
    return base_resolver(association, visitc);
  };

  std::ranges::move(
      std::views::transform(
          std::views::filter(associations, std::not_fn(is_rvalue)),
          resolve_with_visitor),
      std::inserter(resolved, resolved.begin()));

  return resolved;
}

template <typename Range>
requires std::same_as<RuleIr, std::ranges::range_value_t<Range>>
    std::vector<Rule>
    resolve_irs(const std::map<std::string_view, std::string> &macros,
                Range irs) {

  const auto resolve_ir = [macros](const auto &ir) {
    const auto visitc = make_visitc<ValueType>(Resolver{macros});
    const auto target = visitc(ir.target);

    /* const */ auto prereqs =
        copy_collect(std::views::transform(ir.prereqs, visitc));
    const auto resolve_action_list =
        [&](const std::vector<ValueType> &action_list) {
          const auto action_visitc = make_visitc<ValueType>(ActionResolver{
              .target = target, .prereqs = prereqs, .macros = macros});

          return foldl(std::views::transform(action_list, action_visitc), " ");
        };

    /* const */ auto actions =
        copy_collect(std::views::transform(ir.actions, resolve_action_list));

    return Rule{.target = target,
                .prereqs = std::move(prereqs),
                .actions = std::move(actions)};
  };

  return copy_collect(std::views::transform(irs, resolve_ir));
}

template <typename T>
std::set<T, std::less<>>
into_set(std::vector<T> vs) requires std::move_constructible<T> {
  return std::set<T, std::less<>>{
      std::make_move_iterator(vs.begin()),
      std::make_move_iterator(vs.end()),
  };
}

} // namespace detail

Environment
parse_state(Ir ir) {
  /* const */ auto macros = detail::resolve_associations(ir.associations);
  /* const */ auto rules = detail::resolve_irs(macros, ir.rules);

  // we want to crash if rules is empty
  // FIXME: make this a FabException exception
  const std::string_view head = rules.at(0).target;
  return Environment{.macros = std::move(macros),
                     .rules = detail::into_set(std::move(rules)),
                     .head = head};
}
} // namespace resolve
} // namespace detail

std::vector<Token>
lex(std::string_view source) {
  detail::LexState state{source};
  auto tokens = std::vector<Token>{};

  while (!state.eof()) {
    switch (state.next()) {
    case '\t':
      [[fallthrough]];
    case '\n':
      [[fallthrough]];
    case ' ':
      break;
    case '#':
      state.eat_until([](char c) { return '\n' == c; });
      state.eat('\n');
      break;
    case ':':
      state.eat('=');
      tokens.push_back(Token::make<TokenType::Eq>());
      break;
    case ';':
      tokens.push_back(Token::make<TokenType::SemiColon>());
      break;
    case '{':
      tokens.push_back(Token::make<TokenType::LBrace>());
      break;
    case '}':
      tokens.push_back(Token::make<TokenType::RBrace>());
      break;
    case '<':
      state.eat('-');
      tokens.push_back(Token::make<TokenType::Arrow>());
      break;
    case '[':
      if (state.peek() == '*') {
        state.eat('*');
        state.eat('.');
        auto [begin, end] = state.eat_until([](char c) { return c == ']'; });
        state.eat(']');
        tokens.push_back(
            Token::make<TokenType::Stencil>(state.extract_lexeme(begin, end)));
        break;
      } else {
        auto [begin, end] = state.eat_until([](char c) { return c == ']'; });
        state.eat(']');
        tokens.push_back(
            Token::make<TokenType::Fill>(state.extract_lexeme(begin, end)));
        break;
      }
    case '$': {
      if (state.peek() == '@') {
        state.eat('@');
        tokens.push_back(Token::make<TokenType::TargetAlias>());
        break;
      }

      if (state.peek() == '<') {
        state.eat('<');
        tokens.push_back(Token::make<TokenType::PrereqAlias>());
        break;
      }

      state.eat('(');
      auto [begin, end] = state.eat_until([](char c) { return c == ')'; });
      tokens.push_back(
          Token::make<TokenType::Macro>(state.extract_lexeme(begin, end)));
      state.eat(')');
      break;
    }
    default: {
      auto [begin, end] = state.eat_until(
          [](char c) { return c == ' ' || c == '\n' || c == ';'; });

      tokens.push_back(Token::make<TokenType::Iden>(
          state.extract_lexeme(std::prev(begin), end)));
      break;
    }
    }
  }

  tokens.push_back(Token::make<TokenType::Eof>());
  return tokens;
}

Environment
parse(std::vector<Token> &&tokens) {
  auto state = detail::ParseState{std::move(tokens)};
  while (!state.eof()) {
    state.stmt_list();
  }

  return detail::resolve::parse_state(std::move(state).into_ir());
}

bool
Environment::is_leaf(std::string_view rule) const {
  return !rules.contains(rule);
}

const Rule &
Environment::get(std::string_view target) const {
  return find_or_throw(rules, target, [&target] {
    return detail::FabError(detail::FabError::UnknownTarget{.target = target});
  });
}

std::ostream &
operator<<(std::ostream &os, const Token &token) {
  os << token.token_type();

  switch (token.token_type()) {
  case TokenType::Fill:
    os << "['" << token.lexeme<TokenType::Fill>() << "']";
  case TokenType::Iden:
    os << "['" << token.lexeme<TokenType::Iden>() << "']";
  case TokenType::Macro:
    os << "['" << token.lexeme<TokenType::Macro>() << "']";
  case TokenType::Stencil:
    os << "['" << token.lexeme<TokenType::Stencil>() << "']";
  default:
    break;
  }

  return os;
}

std::ostream &
operator<<(std::ostream &os, const TokenType &ty) {
  switch (ty) {
  case TokenType::Arrow:
    return os << "ARROW";
  case TokenType::Eof:
    return os << "EOF";
  case TokenType::Eq:
    return os << "EQ";
  case TokenType::Fill:
    return os << "FILL";
  case TokenType::Iden:
    return os << "IDEN";
  case TokenType::LBrace:
    return os << "LBRACE";
  case TokenType::Macro:
    return os << "MACRO";
  case TokenType::PrereqAlias:
    return os << "PREREQALIAS";
  case TokenType::RBrace:
    return os << "RBRACE";
  case TokenType::SemiColon:
    return os << "SEMICOLON";
  case TokenType::Stencil:
    return os << "STENCIL";
  case TokenType::TargetAlias:
    return os << "TARGETALIAS";
  default:
    throw std::runtime_error{"unhandled token!"};
  }
}

std::ostream &
operator<<(std::ostream &os, const Environment &env) {
  for (auto r : env.rules) {
    os << r;
  }

  return os;
}

std::ostream &
operator<<(std::ostream &os, const Rule &r) {
  os << "{.target = " << r.target;
  os << ", .prereqs = [";

  {
    bool first = true;
    for (auto d : r.prereqs) {
      if (!first) {
        os << ", ";
      }

      os << d;
      first = false;
    }
  }

  os << "]"
     << ", .actions = [";

  {
    bool first = true;
    for (auto a : r.actions) {
      if (!first) {
        os << ", ";
      }

      os << a;
      first = false;
    }
  }

  os << "]"
     << "}";

  return os;
}
